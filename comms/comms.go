package comms

/*
 * Dual-licensed under Apache-2.0 and MIT.
 *
 * You can get a copy of the Apache License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * You can also get a copy of the MIT License at
 *
 * http://opensource.org/licenses/MIT
 *
 * @wcgcyx - https://github.com/wcgcyx
 */

import (
	"context"
	"crypto/rand"
	"encoding/binary"
	"fmt"
	"time"

	"github.com/libp2p/go-libp2p-core/network"
	"github.com/wcgcyx/fcr/crypto"
	"github.com/wcgcyx/fcr/io"
)

// Request represents a standard request in the payment network.
type Request struct {
	// Network stream
	conn   network.Stream
	signer crypto.Signer
	// Request fields
	CurrencyID byte
	FromAddr   string
	ToAddr     string
	// Secrets for two-way verification.
	secret1 [32]byte // Generated by the requester.
	secret2 [32]byte // Generated by the responder.
	// Flag for the first request out.
	first bool
	// Data for the first request in.
	data []byte
}

// encode encodes a request to bytes.
//
// @input - data, sig type, signature.
//
// @output - data (petty data, secrets not included).
func (r Request) encode(data []byte, sigType byte, signature []byte) []byte {
	res := make([]byte, 0)
	// Add currency ID.
	res = append(res, r.CurrencyID)
	// Add sender and length.
	length := make([]byte, 2)
	binary.BigEndian.PutUint16(length, uint16(len(r.FromAddr)))
	res = append(res, append(length, []byte(r.FromAddr)...)...)
	// Add recipient and length.
	length = make([]byte, 2)
	binary.BigEndian.PutUint16(length, uint16(len(r.ToAddr)))
	res = append(res, append(length, []byte(r.ToAddr)...)...)
	// Add data and length
	length = make([]byte, 2)
	binary.BigEndian.PutUint16(length, uint16(len(data)))
	res = append(res, append(length, data...)...)
	// Add signature
	res = append(res, sigType)
	length = make([]byte, 2)
	binary.BigEndian.PutUint16(length, uint16(len(signature)))
	res = append(res, append(length, signature...)...)
	return res
}

// decode decodes a request from given data.
//
// @input - data (petty data, secrets not included).
//
// @output - data, sig type, signature, error.
func (r *Request) decode(data []byte) ([]byte, byte, []byte, error) {
	// Get currency id.
	if len(data) < 1 {
		return nil, 0, nil, fmt.Errorf("fail to decode currency id, not enough data")
	}
	r.CurrencyID = data[0]
	data = data[1:]
	// Get from address.
	if len(data) < 2 {
		return nil, 0, nil, fmt.Errorf("fail to decode sender length, not enough data")
	}
	length := data[0:2]
	data = data[2:]
	size := binary.BigEndian.Uint16(length)
	if uint16(len(data)) < size {
		return nil, 0, nil, fmt.Errorf("fail to decode sender, not enough data")
	}
	r.FromAddr = string(data[0:size])
	data = data[size:]
	// Get to address.
	if len(data) < 2 {
		return nil, 0, nil, fmt.Errorf("fail to decode recipient length, not enough data")
	}
	length = data[0:2]
	data = data[2:]
	size = binary.BigEndian.Uint16(length)
	if uint16(len(data)) < size {
		return nil, 0, nil, fmt.Errorf("fail to decode recipient, not enough data")
	}
	r.ToAddr = string(data[0:size])
	data = data[size:]
	// Get data
	if len(data) < 2 {
		return nil, 0, nil, fmt.Errorf("fail to decode data length, not enough data")
	}
	length = data[0:2]
	data = data[2:]
	size = binary.BigEndian.Uint16(length)
	if uint16(len(data)) < size {
		return nil, 0, nil, fmt.Errorf("fail to decode data, not enough data")
	}
	resData := make([]byte, size)
	copy(resData, data[0:size])
	data = data[size:]
	// Get signature
	if len(data) < 1 {
		return nil, 0, nil, fmt.Errorf("fail to decode signature type, not enough data")
	}
	sigType := data[0]
	data = data[1:]
	if len(data) < 2 {
		return nil, 0, nil, fmt.Errorf("fail to decode signature length, not enough data")
	}
	length = data[0:2]
	data = data[2:]
	size = binary.BigEndian.Uint16(length)
	if uint16(len(data)) < size {
		return nil, 0, nil, fmt.Errorf("fail to decode signature, not enough data")
	}
	signature := make([]byte, size)
	copy(signature, data[0:size])
	data = data[size:]
	if len(data) != 0 {
		return nil, 0, nil, fmt.Errorf("fail to decode, unknown residual")
	}
	return resData, sigType, signature, nil
}

// encode encodes a request's data and sig to bytes.
//
// @input - raw data, sig type, signature.
//
// @output - encoded data.
func encode(data []byte, sigType byte, signature []byte) []byte {
	res := make([]byte, 0)
	// Add data and length
	length := make([]byte, 2)
	binary.BigEndian.PutUint16(length, uint16(len(data)))
	res = append(res, append(length, data...)...)
	// Add signature
	res = append(res, sigType)
	length = make([]byte, 2)
	binary.BigEndian.PutUint16(length, uint16(len(signature)))
	res = append(res, append(length, signature...)...)
	return res
}

// decode decodes a request's data and sig from given data.
//
// @input - encoded data.
//
// @output - raw data, sig type, signature, error.
func decode(data []byte) ([]byte, byte, []byte, error) {
	// Get data
	if len(data) < 2 {
		return nil, 0, nil, fmt.Errorf("fail to decode data length, not enough data")
	}
	length := data[0:2]
	data = data[2:]
	size := binary.BigEndian.Uint16(length)
	if uint16(len(data)) < size {
		return nil, 0, nil, fmt.Errorf("fail to decode data, not enough data")
	}
	resData := make([]byte, size)
	copy(resData, data[0:size])
	data = data[size:]
	// Get signature
	if len(data) < 1 {
		return nil, 0, nil, fmt.Errorf("fail to decode signature type, not enough data")
	}
	sigType := data[0]
	data = data[1:]
	if len(data) < 2 {
		return nil, 0, nil, fmt.Errorf("fail to decode signature length, not enough data")
	}
	length = data[0:2]
	data = data[2:]
	size = binary.BigEndian.Uint16(length)
	if uint16(len(data)) < size {
		return nil, 0, nil, fmt.Errorf("fail to decode signature, not enough data")
	}
	signature := make([]byte, size)
	copy(signature, data[0:size])
	data = data[size:]
	if len(data) != 0 {
		return nil, 0, nil, fmt.Errorf("fail to decode, unknown residual")
	}
	return resData, sigType, signature, nil
}

// NewRequestOut creates a request for sending out.
//
// @input - context, operation timeout, io timeout, network stream, signer, currency id, recipient address, data.
//
// @output - request, error.
func NewRequestOut(ctx context.Context, opTimeout time.Duration, ioTimeout time.Duration, conn network.Stream, signer crypto.Signer, currencyID byte, toAddr string) (Request, error) {
	r := Request{
		conn:       conn,
		signer:     signer,
		CurrencyID: currencyID,
		ToAddr:     toAddr,
	}
	// Exchange secrets
	// First get secret
	subCtx, cancel := context.WithTimeout(ctx, ioTimeout)
	defer cancel()
	raw, err := io.Read(subCtx, r.conn)
	if err != nil {
		return Request{}, err
	}
	if len(raw) != 33 {
		return Request{}, fmt.Errorf("expect responder secret 32, got %v", len(raw))
	}
	// Version is the first byte
	if raw[0] != 1 {
		return Request{}, fmt.Errorf("version mismatch, expect 1, got %v", raw[0])
	}
	raw = raw[1:]
	copy(r.secret2[:], raw)
	// Generate secret
	var secret1 [32]byte
	_, err = rand.Read(secret1[:])
	if err != nil {
		return Request{}, err
	}
	r.secret1 = secret1
	// Get from address
	subCtx, cancel = context.WithTimeout(ctx, opTimeout)
	defer cancel()
	_, self, err := r.signer.GetAddr(subCtx, r.CurrencyID)
	if err != nil {
		return Request{}, err
	}
	r.FromAddr = self
	r.first = true
	return r, nil
}

// Send sends a request out.
//
// @input - context, operation timeout, io timeout, data.
//
// @output - error.
func (r *Request) Send(ctx context.Context, opTimeout time.Duration, ioTimeout time.Duration, data []byte) error {
	subCtx, cancel := context.WithTimeout(ctx, opTimeout)
	defer cancel()
	// Sign the request
	sigType, sig, err := r.signer.Sign(subCtx, r.CurrencyID, append(data, append([]byte(r.ToAddr), r.secret2[:]...)...))
	if err != nil {
		return err
	}
	// Check if this is the first data to send.
	var reqData []byte
	if r.first {
		reqData = r.encode(data, sigType, sig)
		reqData = append(r.secret1[:], reqData...)
	} else {
		reqData = encode(data, sigType, sig)
	}
	// Send
	subCtx, cancel = context.WithTimeout(ctx, ioTimeout)
	defer cancel()
	err = io.Write(subCtx, r.conn, reqData)
	if err != nil {
		return err
	}
	r.first = false
	return nil
}

// GetResponse gets a response from a request.
//
// @input - context, io timeout.
//
// @output - response status, response data, error.
func (r *Request) GetResponse(ctx context.Context, ioTimeout time.Duration) (bool, []byte, error) {
	// Get response
	subCtx, cancel := context.WithTimeout(ctx, ioTimeout)
	defer cancel()
	resp, err := io.Read(subCtx, r.conn)
	if err != nil {
		return false, nil, err
	}
	// Decode status & data
	if len(resp) < 2 {
		return false, nil, fmt.Errorf("fail to decode data length, not enough data")
	}
	length := resp[0:2]
	resp = resp[2:]
	size := binary.BigEndian.Uint16(length)
	if size < 1 {
		return false, nil, fmt.Errorf("empty data received")
	}
	if uint16(len(resp)) < size {
		return false, nil, fmt.Errorf("fail to decode data, not enough data")
	}
	succeed := resp[0] == 1
	respData := resp[1:size]
	resp = resp[size:]
	// Decode signature
	if len(resp) < 1 {
		return false, nil, fmt.Errorf("fail to decode signature type, not enough data")
	}
	sigType := resp[0]
	resp = resp[1:]
	if len(resp) < 2 {
		return false, nil, fmt.Errorf("fail to decode signature length, not enough data")
	}
	length = resp[0:2]
	resp = resp[2:]
	size = binary.BigEndian.Uint16(length)
	if uint16(len(resp)) < size {
		return false, nil, fmt.Errorf("fail to decode signature, not enough data")
	}
	sig := resp[0:size]
	resp = resp[size:]
	if len(resp) != 0 {
		return false, nil, fmt.Errorf("fail to decode, unknown residual")
	}
	// Verify signature
	toSign := append([]byte{0}, respData...)
	if succeed {
		toSign[0] = 1
	}
	err = crypto.Verify(r.CurrencyID, append(toSign, append([]byte(r.FromAddr), r.secret1[:]...)...), sigType, sig, r.ToAddr)
	if err != nil {
		return false, nil, err
	}
	return succeed, respData, nil
}

// NewRequestIn creates a request for receiving.
//
// @input - context, operation timeout, io timeout, network stream, signer.
//
// @output - request.
func NewRequestIn(ctx context.Context, opTimeout time.Duration, ioTimeout time.Duration, conn network.Stream, signer crypto.Signer) (Request, error) {
	r := Request{
		conn:   conn,
		signer: signer,
	}
	// Exchange secrets
	// First generate secret
	var secret2 [32]byte
	_, err := rand.Read(secret2[:])
	if err != nil {
		return Request{}, err
	}
	// Write version 1 at front
	subCtx, cancel := context.WithTimeout(ctx, ioTimeout)
	defer cancel()
	err = io.Write(subCtx, conn, append([]byte{1}, secret2[:]...))
	if err != nil {
		return Request{}, err
	}
	r.secret2 = secret2
	// Read data
	subCtx, cancel = context.WithTimeout(ctx, ioTimeout)
	defer cancel()
	raw, err := io.Read(subCtx, conn)
	if err != nil {
		return Request{}, err
	}
	// The first 32 bytes are secret 1.
	if len(raw) <= 32 {
		return Request{}, fmt.Errorf("expect sender secret 32, got %v", len(raw))
	}
	copy(r.secret1[:], raw[:32])
	raw = raw[32:]
	// decode request body for the first run
	reqData, sigType, signature, err := r.decode(raw)
	if err != nil {
		return Request{}, err
	}
	// Verify request signature
	err = crypto.Verify(r.CurrencyID, append(reqData, append([]byte(r.ToAddr), r.secret2[:]...)...), sigType, signature, r.FromAddr)
	if err != nil {
		return Request{}, err
	}
	// Verify recipient
	subCtx, cancel = context.WithTimeout(ctx, opTimeout)
	defer cancel()
	_, self, err := r.signer.GetAddr(subCtx, r.CurrencyID)
	if err != nil {
		return Request{}, err
	}
	if r.ToAddr != self {
		return Request{}, fmt.Errorf("recipient mismatch, expect %v got %v", self, r.ToAddr)
	}
	// Set first data
	r.data = reqData
	return r, nil
}

// Receive receives a request in.
//
// @input - context, io timeout.
//
// @output - data, error.
func (r *Request) Receive(ctx context.Context, ioTimeout time.Duration) ([]byte, error) {
	if r.data != nil {
		res := r.data
		r.data = nil
		return res, nil
	}
	// Read data
	subCtx, cancel := context.WithTimeout(ctx, ioTimeout)
	defer cancel()
	raw, err := io.Read(subCtx, r.conn)
	if err != nil {
		return nil, err
	}
	data, sigType, sig, err := decode(raw)
	if err != nil {
		return nil, err
	}
	// Verify request signature
	err = crypto.Verify(r.CurrencyID, append(data, append([]byte(r.ToAddr), r.secret2[:]...)...), sigType, sig, r.FromAddr)
	if err != nil {
		return nil, err
	}
	return data, nil
}

// Respond sends a response back to a request.
//
// @input - context, operation timeout, io timeout, response status, response data.
//
// @output - error.
func (r *Request) Respond(ctx context.Context, opTimeout time.Duration, ioTimeout time.Duration, succeed bool, data []byte) error {
	subCtx, cancel := context.WithTimeout(ctx, opTimeout)
	defer cancel()
	// Sign data
	data = append([]byte{0}, data...)
	if succeed {
		data[0] = 1
	}
	sigType, sig, err := r.signer.Sign(subCtx, r.CurrencyID, append(data, append([]byte(r.FromAddr), r.secret1[:]...)...))
	if err != nil {
		return err
	}
	// Get Resp data
	resp := make([]byte, 0)
	// Add data
	length := make([]byte, 2)
	binary.BigEndian.PutUint16(length, uint16(len(data)))
	resp = append(resp, append(length, data...)...)
	// Add signature
	resp = append(resp, sigType)
	length = make([]byte, 2)
	binary.BigEndian.PutUint16(length, uint16(len(sig)))
	resp = append(resp, append(length, sig...)...)
	// Reply
	subCtx, cancel = context.WithTimeout(ctx, ioTimeout)
	defer cancel()
	return io.Write(subCtx, r.conn, resp)
}
